{
  "last_node_id": 30,
  "last_link_id": 51,
  "nodes": [
    {
      "id": 25,
      "type": "LF_String",
      "pos": [
        1060,
        -290
      ],
      "size": [
        920,
        230
      ],
      "flags": {},
      "order": 6,
      "mode": 0,
      "inputs": [
        {
          "name": "string",
          "type": "STRING",
          "link": 37,
          "widget": {
            "name": "string"
          }
        }
      ],
      "outputs": [
        {
          "name": "string",
          "type": "STRING",
          "links": null,
          "slot_index": 0
        },
        {
          "name": "string_list",
          "type": "STRING",
          "links": [
            38
          ],
          "slot_index": 1,
          "shape": 6
        }
      ],
      "properties": {
        "Node name for S&R": "LF_String",
        "ttNbgOverride": {
          "color": "#222",
          "bgcolor": "#000",
          "groupcolor": "#444"
        }
      },
      "widgets_values": [
        "",
        true,
        {
          "nodes": [
            {
              "icon": "history",
              "id": "class LF_Boolean:\n    @classmethod \n    def INPUT_TYPES(cls):\n        return {\n            \"required\": {\n                \"boolean\": (\"BOOLEAN\", {\"default\": False, \"tooltip\": \"Boolean value.\"}),\n                \"enable_history\": (\"BOOLEAN\", {\"default\": True, \"tooltip\": \"Enables history, saving the execution value and date of the widget.\"}),\n            },\n            \"optional\": {\n                \"json_input\": (\"KUL_HISTORY\", {\"default\": {}}),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_IS_LIST = (False, True)\n    RETURN_NAMES = (\"boolean\", \"boolean_list\")\n    RETURN_TYPES = (\"BOOLEAN\", \"BOOLEAN\")\n\n    def on_exec(self, node_id: str, boolean: bool, enable_history: bool, json_input: dict = {}):\n        boolean = normalize_list_to_value(boolean)\n        enable_history = normalize_list_to_value(enable_history)\n        json_input = normalize_json_input(json_input)\n\n        nodes = json_input.get(\"nodes\", [])\n        dataset = {\n            \"nodes\": nodes\n        }\n\n        if enable_history:\n            create_history_node(str(boolean), nodes)\n            \n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}boolean\", {\n            \"node\": node_id, \n            \"dataset\": dataset\n        })\n\n        return (boolean, [boolean])",
              "description": "Execution date: 31/10/2024, 05:47:54.",
              "value": "class LF_Boolean:\n    @classmethod \n    def INPUT_TYPES(cls):\n        return {\n            \"required\": {\n                \"boolean\": (\"BOOLEAN\", {\"default\": False, \"tooltip\": \"Boolean value.\"}),\n                \"enable_history\": (\"BOOLEAN\", {\"default\": True, \"tooltip\": \"Enables history, saving the execution value and date of the widget.\"}),\n            },\n            \"optional\": {\n                \"json_input\": (\"KUL_HISTORY\", {\"default\": {}}),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_IS_LIST = (False, True)\n    RETURN_NAMES = (\"boolean\", \"boolean_list\")\n    RETURN_TYPES = (\"BOOLEAN\", \"BOOLEAN\")\n\n    def on_exec(self, node_id: str, boolean: bool, enable_history: bool, json_input: dict = {}):\n        boolean = normalize_list_to_value(boolean)\n        enable_history = normalize_list_to_value(enable_history)\n        json_input = normalize_json_input(json_input)\n\n        nodes = json_input.get(\"nodes\", [])\n        dataset = {\n            \"nodes\": nodes\n        }\n\n        if enable_history:\n            create_history_node(str(boolean), nodes)\n            \n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}boolean\", {\n            \"node\": node_id, \n            \"dataset\": dataset\n        })\n\n        return (boolean, [boolean])"
            },
            {
              "icon": "history",
              "id": "class LF_DisplayBoolean:\n    @classmethod \n    def INPUT_TYPES(cls):\n        return {\n            \"required\": {\n                \"boolean\": (\"BOOLEAN\", {\"default\": False, \"forceInput\": True, \"tooltip\": \"Boolean value.\"}),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_NODE = True\n    RETURN_NAMES = (\"boolean\",)\n    RETURN_TYPES = (\"BOOLEAN\",)\n\n    def on_exec(self, node_id: str, boolean: bool):\n        display_boolean = normalize_input_list(boolean)\n\n        if len(display_boolean) > 1:\n            markdown_value = \"\\n\\n\".join(f\"{i+1}. {item}\" for i, item in enumerate(display_boolean))\n        else:\n            markdown_value = str(display_boolean[0]) \n        \n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}displayboolean\", {\n            \"node\": node_id, \n            \"value\": markdown_value,\n        })\n\n        return (boolean,)",
              "description": "Execution date: 31/10/2024, 05:47:54.",
              "value": "class LF_DisplayBoolean:\n    @classmethod \n    def INPUT_TYPES(cls):\n        return {\n            \"required\": {\n                \"boolean\": (\"BOOLEAN\", {\"default\": False, \"forceInput\": True, \"tooltip\": \"Boolean value.\"}),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_NODE = True\n    RETURN_NAMES = (\"boolean\",)\n    RETURN_TYPES = (\"BOOLEAN\",)\n\n    def on_exec(self, node_id: str, boolean: bool):\n        display_boolean = normalize_input_list(boolean)\n\n        if len(display_boolean) > 1:\n            markdown_value = \"\\n\\n\".join(f\"{i+1}. {item}\" for i, item in enumerate(display_boolean))\n        else:\n            markdown_value = str(display_boolean[0]) \n        \n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}displayboolean\", {\n            \"node\": node_id, \n            \"value\": markdown_value,\n        })\n\n        return (boolean,)"
            }
          ]
        },
        936417278851491,
        "randomize",
        {
          "nodes": [
            {
              "icon": "history",
              "id": "class LF_WallOfText:\n    @classmethod \n    def INPUT_TYPES(self):\n        return {\n            \"required\": {\n                \"separator\": (Input.STRING, {\n                    \"default\": \", \", \n                    \"tooltip\": \"Character(s) separating each string apart.\"}),\n                \"text_1\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"multiline\": True, \n                    \"tooltip\": \"The first required string.\"}),\n                \"text_2\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"multiline\": True, \n                    \"tooltip\": \"The second required string.\"}),\n            },\n            \"optional\": {\n                \"text_3\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The third optional string.\"\n                }),\n                \"text_4\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The fourth optional string.\"\n                }),\n                \"text_5\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The fifth optional string.\"\n                }),\n                \"text_6\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The sixth optional string.\"\n                }),\n                \"text_7\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The seventh optional string.\"\n                }),\n                \"text_8\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The eighth optional string.\"\n                }),\n                \"text_9\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The ninth optional string.\"\n                }),\n                \"text_10\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The tenth optional string.\"\n                }),\n                \"shuffle_inputs\": (Input.BOOLEAN, {\n                    \"default\": False, \n                    \"tooltip\": \"Toggle shuffling of input strings.\"\n                }),\n                \"seed\": (Input.INTEGER, {\n                    \"default\": 42, \n                    \"max\": INT_MAX, \n                    \"tooltip\": \"Seed to control the randomness of the shuffling.\"\n                }),\n                \"ui_widget\": (Input.LF_CODE, {\n                    \"default\": \"\"\n                }),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_IS_LIST = (False, True)\n    RETURN_NAMES = (\"string\", \"string_list\")\n    RETURN_TYPES = (\"STRING\", \"STRING\")\n\n    def on_exec(self, **kwargs: dict):\n        texts: list[str] = [normalize_list_to_value(kwargs.get(f\"text_{i}\", \"\")) for i in range(1, 11)]\n\n        if len(texts) > 1:\n            separator = kwargs.get(\"separator\", \"\")\n            shuffle_inputs = kwargs.get(\"shuffle_inputs\", False)\n            if shuffle_inputs:\n                seed = kwargs.get(\"seed\", 42)\n                random.seed(seed)\n                random.shuffle(texts)\n            wall_of_text = separator.join([text for text in texts if text])\n        else:\n            wall_of_text = texts[0]\n\n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}walloftext\", {\n            \"node\": kwargs.get(\"node_id\"), \n            \"value\": wall_of_text,\n        })\n\n        return (wall_of_text, wall_of_text)",
              "description": "Execution date: 17/02/2025, 10:21:09.",
              "value": "class LF_WallOfText:\n    @classmethod \n    def INPUT_TYPES(self):\n        return {\n            \"required\": {\n                \"separator\": (Input.STRING, {\n                    \"default\": \", \", \n                    \"tooltip\": \"Character(s) separating each string apart.\"}),\n                \"text_1\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"multiline\": True, \n                    \"tooltip\": \"The first required string.\"}),\n                \"text_2\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"multiline\": True, \n                    \"tooltip\": \"The second required string.\"}),\n            },\n            \"optional\": {\n                \"text_3\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The third optional string.\"\n                }),\n                \"text_4\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The fourth optional string.\"\n                }),\n                \"text_5\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The fifth optional string.\"\n                }),\n                \"text_6\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The sixth optional string.\"\n                }),\n                \"text_7\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The seventh optional string.\"\n                }),\n                \"text_8\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The eighth optional string.\"\n                }),\n                \"text_9\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The ninth optional string.\"\n                }),\n                \"text_10\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The tenth optional string.\"\n                }),\n                \"shuffle_inputs\": (Input.BOOLEAN, {\n                    \"default\": False, \n                    \"tooltip\": \"Toggle shuffling of input strings.\"\n                }),\n                \"seed\": (Input.INTEGER, {\n                    \"default\": 42, \n                    \"max\": INT_MAX, \n                    \"tooltip\": \"Seed to control the randomness of the shuffling.\"\n                }),\n                \"ui_widget\": (Input.LF_CODE, {\n                    \"default\": \"\"\n                }),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_IS_LIST = (False, True)\n    RETURN_NAMES = (\"string\", \"string_list\")\n    RETURN_TYPES = (\"STRING\", \"STRING\")\n\n    def on_exec(self, **kwargs: dict):\n        texts: list[str] = [normalize_list_to_value(kwargs.get(f\"text_{i}\", \"\")) for i in range(1, 11)]\n\n        if len(texts) > 1:\n            separator = kwargs.get(\"separator\", \"\")\n            shuffle_inputs = kwargs.get(\"shuffle_inputs\", False)\n            if shuffle_inputs:\n                seed = kwargs.get(\"seed\", 42)\n                random.seed(seed)\n                random.shuffle(texts)\n            wall_of_text = separator.join([text for text in texts if text])\n        else:\n            wall_of_text = texts[0]\n\n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}walloftext\", {\n            \"node\": kwargs.get(\"node_id\"), \n            \"value\": wall_of_text,\n        })\n\n        return (wall_of_text, wall_of_text)"
            }
          ]
        }
      ],
      "color": "#ffffff",
      "bgcolor": "#ffffff",
      "shape": 1
    },
    {
      "id": 6,
      "type": "LF_DisplayJSON",
      "pos": [
        725,
        135
      ],
      "size": [
        650,
        995
      ],
      "flags": {},
      "order": 3,
      "mode": 0,
      "inputs": [
        {
          "name": "json_input",
          "type": "JSON",
          "link": 46
        }
      ],
      "outputs": [
        {
          "name": "json",
          "type": "JSON",
          "links": [],
          "slot_index": 0
        }
      ],
      "properties": {
        "Node name for S&R": "LF_DisplayJSON",
        "ttNbgOverride": {
          "color": "#222",
          "bgcolor": "#000",
          "groupcolor": "#444"
        }
      },
      "widgets_values": [
        "{\n  \"file\": \"F:\\\\primitives.py\",\n  \"name\": \"LF_WallOfText\",\n  \"code\": \"class LF_WallOfText:\\n    @classmethod \\n    def INPUT_TYPES(self):\\n        return {\\n            \\\"required\\\": {\\n                \\\"separator\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\", \\\", \\n                    \\\"tooltip\\\": \\\"Character(s) separating each string apart.\\\"}),\\n                \\\"text_1\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"multiline\\\": True, \\n                    \\\"tooltip\\\": \\\"The first required string.\\\"}),\\n                \\\"text_2\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"multiline\\\": True, \\n                    \\\"tooltip\\\": \\\"The second required string.\\\"}),\\n            },\\n            \\\"optional\\\": {\\n                \\\"text_3\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"defaultInput\\\": True, \\n                    \\\"tooltip\\\": \\\"The third optional string.\\\"\\n                }),\\n                \\\"text_4\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"defaultInput\\\": True, \\n                    \\\"tooltip\\\": \\\"The fourth optional string.\\\"\\n                }),\\n                \\\"text_5\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"defaultInput\\\": True, \\n                    \\\"tooltip\\\": \\\"The fifth optional string.\\\"\\n                }),\\n                \\\"text_6\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"defaultInput\\\": True, \\n                    \\\"tooltip\\\": \\\"The sixth optional string.\\\"\\n                }),\\n                \\\"text_7\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"defaultInput\\\": True, \\n                    \\\"tooltip\\\": \\\"The seventh optional string.\\\"\\n                }),\\n                \\\"text_8\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"defaultInput\\\": True, \\n                    \\\"tooltip\\\": \\\"The eighth optional string.\\\"\\n                }),\\n                \\\"text_9\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"defaultInput\\\": True, \\n                    \\\"tooltip\\\": \\\"The ninth optional string.\\\"\\n                }),\\n                \\\"text_10\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"defaultInput\\\": True, \\n                    \\\"tooltip\\\": \\\"The tenth optional string.\\\"\\n                }),\\n                \\\"shuffle_inputs\\\": (Input.BOOLEAN, {\\n                    \\\"default\\\": False, \\n                    \\\"tooltip\\\": \\\"Toggle shuffling of input strings.\\\"\\n                }),\\n                \\\"seed\\\": (Input.INTEGER, {\\n                    \\\"default\\\": 42, \\n                    \\\"max\\\": INT_MAX, \\n                    \\\"tooltip\\\": \\\"Seed to control the randomness of the shuffling.\\\"\\n                }),\\n                \\\"ui_widget\\\": (Input.LF_CODE, {\\n                    \\\"default\\\": \\\"\\\"\\n                }),\\n            },\\n            \\\"hidden\\\": {\\n                \\\"node_id\\\": \\\"UNIQUE_ID\\\"\\n            }\\n        }\\n\\n    CATEGORY = CATEGORY\\n    FUNCTION = FUNCTION\\n    OUTPUT_IS_LIST = (False, True)\\n    RETURN_NAMES = (\\\"string\\\", \\\"string_list\\\")\\n    RETURN_TYPES = (\\\"STRING\\\", \\\"STRING\\\")\\n\\n    def on_exec(self, **kwargs: dict):\\n        texts: list[str] = [normalize_list_to_value(kwargs.get(f\\\"text_{i}\\\", \\\"\\\")) for i in range(1, 11)]\\n\\n        if len(texts) > 1:\\n            separator = kwargs.get(\\\"separator\\\", \\\"\\\")\\n            shuffle_inputs = kwargs.get(\\\"shuffle_inputs\\\", False)\\n            if shuffle_inputs:\\n                seed = kwargs.get(\\\"seed\\\", 42)\\n                random.seed(seed)\\n                random.shuffle(texts)\\n            wall_of_text = separator.join([text for text in texts if text])\\n        else:\\n            wall_of_text = texts[0]\\n\\n        PromptServer.instance.send_sync(f\\\"{EVENT_PREFIX}walloftext\\\", {\\n            \\\"node\\\": kwargs.get(\\\"node_id\\\"), \\n            \\\"value\\\": wall_of_text,\\n        })\\n\\n        return (wall_of_text, wall_of_text)\",\n  \"constants\": [\n    \"LF_CODE\",\n    \"INTEGER\",\n    \"EVENT_PREFIX\",\n    \"INT_MAX\",\n    \"INPUT_TYPES\",\n    \"BOOLEAN\",\n    \"STRING\",\n    \"UNIQUE_ID\"\n  ],\n  \"helperFunctions\": [\n    \"get\",\n    \"shuffle\",\n    \"join\",\n    \"send_sync\",\n    \"len\",\n    \"normalize_list_to_value\",\n    \"range\",\n    \"return\",\n    \"seed\",\n    \"Character\"\n  ]\n}"
      ],
      "color": "#ffffff",
      "bgcolor": "#ffffff",
      "shape": 1
    },
    {
      "id": 29,
      "type": "LF_GetValueFromJSON",
      "pos": [
        725,
        -1130
      ],
      "size": [
        295,
        495
      ],
      "flags": {},
      "order": 5,
      "mode": 0,
      "inputs": [
        {
          "name": "json_input",
          "type": "JSON",
          "link": 49
        }
      ],
      "outputs": [
        {
          "name": "json",
          "type": "JSON",
          "links": null,
          "slot_index": 0
        },
        {
          "name": "string",
          "type": "STRING",
          "links": [
            50
          ],
          "slot_index": 1
        },
        {
          "name": "number",
          "type": "NUMBER",
          "links": null
        },
        {
          "name": "int",
          "type": "INT",
          "links": null
        },
        {
          "name": "float",
          "type": "FLOAT",
          "links": null
        },
        {
          "name": "boolean",
          "type": "BOOLEAN",
          "links": null
        }
      ],
      "properties": {
        "Node name for S&R": "LF_GetValueFromJSON",
        "ttNbgOverride": {
          "color": "#222",
          "bgcolor": "#000",
          "groupcolor": "#444"
        }
      },
      "widgets_values": [
        "helperFunctions",
        0,
        "## Selected key\nhelperFunctions\n\n## Content:\n['get', 'shuffle', 'join', 'send_sync', 'len', 'normalize_list_to_value', 'range', 'return', 'seed', 'Character']"
      ],
      "color": "#ffffff",
      "bgcolor": "#ffffff",
      "shape": 1
    },
    {
      "id": 8,
      "type": "LF_GetValueFromJSON",
      "pos": [
        725,
        -565
      ],
      "size": [
        290,
        605
      ],
      "flags": {},
      "order": 4,
      "mode": 0,
      "inputs": [
        {
          "name": "json_input",
          "type": "JSON",
          "link": 47
        }
      ],
      "outputs": [
        {
          "name": "json",
          "type": "JSON",
          "links": null,
          "slot_index": 0
        },
        {
          "name": "string",
          "type": "STRING",
          "links": [
            37
          ],
          "slot_index": 1
        },
        {
          "name": "number",
          "type": "NUMBER",
          "links": null
        },
        {
          "name": "int",
          "type": "INT",
          "links": null
        },
        {
          "name": "float",
          "type": "FLOAT",
          "links": null
        },
        {
          "name": "boolean",
          "type": "BOOLEAN",
          "links": null
        }
      ],
      "properties": {
        "Node name for S&R": "LF_GetValueFromJSON",
        "ttNbgOverride": {
          "color": "#222",
          "bgcolor": "#000",
          "groupcolor": "#444"
        }
      },
      "widgets_values": [
        "code",
        0,
        "## Selected key\ncode\n\n## Content:\nclass LF_WallOfText:\n    @classmethod \n    def INPUT_TYPES(self):\n        return {\n            \"required\": {\n                \"separator\": (Input.STRING, {\n                    \"default\": \", \", \n                    \"tooltip\": \"Character(s) separating each string apart.\"}),\n                \"text_1\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"multiline\": True, \n                    \"tooltip\": \"The first required string.\"}),\n                \"text_2\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"multiline\": True, \n                    \"tooltip\": \"The second required string.\"}),\n            },\n            \"optional\": {\n                \"text_3\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The third optional string.\"\n                }),\n                \"text_4\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The fourth optional string.\"\n                }),\n                \"text_5\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The fifth optional string.\"\n                }),\n                \"text_6\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The sixth optional string.\"\n                }),\n                \"text_7\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The seventh optional string.\"\n                }),\n                \"text_8\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The eighth optional string.\"\n                }),\n                \"text_9\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The ninth optional string.\"\n                }),\n                \"text_10\": (Input.STRING, {\n                    \"default\": \"\", \n                    \"defaultInput\": True, \n                    \"tooltip\": \"The tenth optional string.\"\n                }),\n                \"shuffle_inputs\": (Input.BOOLEAN, {\n                    \"default\": False, \n                    \"tooltip\": \"Toggle shuffling of input strings.\"\n                }),\n                \"seed\": (Input.INTEGER, {\n                    \"default\": 42, \n                    \"max\": INT_MAX, \n                    \"tooltip\": \"Seed to control the randomness of the shuffling.\"\n                }),\n                \"ui_widget\": (Input.LF_CODE, {\n                    \"default\": \"\"\n                }),\n            },\n            \"hidden\": {\n                \"node_id\": \"UNIQUE_ID\"\n            }\n        }\n\n    CATEGORY = CATEGORY\n    FUNCTION = FUNCTION\n    OUTPUT_IS_LIST = (False, True)\n    RETURN_NAMES = (\"string\", \"string_list\")\n    RETURN_TYPES = (\"STRING\", \"STRING\")\n\n    def on_exec(self, **kwargs: dict):\n        texts: list[str] = [normalize_list_to_value(kwargs.get(f\"text_{i}\", \"\")) for i in range(1, 11)]\n\n        if len(texts) > 1:\n            separator = kwargs.get(\"separator\", \"\")\n            shuffle_inputs = kwargs.get(\"shuffle_inputs\", False)\n            if shuffle_inputs:\n                seed = kwargs.get(\"seed\", 42)\n                random.seed(seed)\n                random.shuffle(texts)\n            wall_of_text = separator.join([text for text in texts if text])\n        else:\n            wall_of_text = texts[0]\n\n        PromptServer.instance.send_sync(f\"{EVENT_PREFIX}walloftext\", {\n            \"node\": kwargs.get(\"node_id\"), \n            \"value\": wall_of_text,\n        })\n\n        return (wall_of_text, wall_of_text)"
      ],
      "color": "#ffffff",
      "bgcolor": "#ffffff",
      "shape": 1
    },
    {
      "id": 28,
      "type": "LF_DisplayString",
      "pos": [
        1055,
        -1110
      ],
      "size": [
        285,
        475
      ],
      "flags": {},
      "order": 7,
      "mode": 0,
      "inputs": [
        {
          "name": "string",
          "type": "STRING",
          "link": 50,
          "widget": {
            "name": "string"
          }
        }
      ],
      "outputs": [
        {
          "name": "string",
          "type": "STRING",
          "links": null,
          "slot_index": 0
        }
      ],
      "properties": {
        "Node name for S&R": "LF_DisplayString",
        "ttNbgOverride": {
          "color": "#222",
          "bgcolor": "#000",
          "groupcolor": "#444"
        }
      },
      "widgets_values": [
        "",
        "['get', 'shuffle', 'join', 'send_sync', 'len', 'normalize_list_to_value', 'range', 'return', 'seed', 'Character']"
      ],
      "color": "#ffffff",
      "bgcolor": "#ffffff",
      "shape": 1
    },
    {
      "id": 21,
      "type": "LF_MarkdownDocGenerator",
      "pos": [
        2020,
        -860
      ],
      "size": [
        315,
        800
      ],
      "flags": {},
      "order": 8,
      "mode": 0,
      "inputs": [
        {
          "name": "prompt",
          "type": 0,
          "link": 38,
          "widget": {
            "name": "prompt"
          }
        },
        {
          "name": "extra_context",
          "type": "STRING",
          "link": null,
          "widget": {
            "name": "extra_context"
          },
          "shape": 7
        }
      ],
      "outputs": [
        {
          "name": "request_json",
          "type": "JSON",
          "links": null
        },
        {
          "name": "response_json",
          "type": "JSON",
          "links": null
        },
        {
          "name": "markdown",
          "type": "STRING",
          "links": [],
          "slot_index": 2
        },
        {
          "name": "markdown_list",
          "type": "STRING",
          "links": [
            39
          ],
          "slot_index": 3,
          "shape": 6
        }
      ],
      "properties": {
        "Node name for S&R": "LF_MarkdownDocGenerator"
      },
      "widgets_values": [
        "",
        0.5,
        2000,
        723557452566082,
        "randomize",
        "http://localhost:5001/v1/chat/completions",
        "",
        "# LF_WallOfText\n\n### Summary\nThe LF_WallOfText node generates a wall of text by concatenating input strings, optionally shuffling them, and sending the result to the PromptServer.\n\n---\n\n## 📥 Inputs\n\n| Parameter      | Type     | Default Value | Description |\n|----------------|----------|---------------|-------------|\n| separator      | STRING   | \", \"          | Character(s) separating each string apart. |\n| text_1         | STRING   | \"\"            | The first required string. |\n| text_2         | STRING   | \"\"            | The second required string. |\n| text_3-10      | STRING   | \"\"            | The third to tenth optional strings. |\n| shuffle_inputs | BOOLEAN  | False         | Toggle shuffling of input strings. |\n| seed           | INTEGER  | 42            | Seed to control the randomness of the shuffling. |\n| ui_widget     | LF_CODE  | \"\"            | Custom UI widget for node configuration. |\n| node_id       | STRING   | UNIQUE_ID     | Node ID (hidden input). |\n\n---\n\n## 📤 Outputs\n\n| Output Name    | Type     | Description |\n|----------------|----------|-------------|\n| string         | STRING   | The generated wall of text. |\n| string_list    | STRING   | The generated wall of text (always returns a single string). |\n\n---\n\n## 🔧 Execution Details\n\n- **Category**: {CATEGORY}\n- **Function Name**: `{FUNCTION}`\n- **Execution Method**: `on_exec`\n- **Unique Features**: Shuffling of input strings, customizable separator, and optional UI widget for node configuration.\n\n---\n\n### 📝 Example Output\n```json\n{\n    \"string\": \"Hello, world! Foo bar baz qux\"\n}\n```\nNote: The actual output will depend on the input values and shuffling configuration."
      ],
      "color": "#ffffff",
      "bgcolor": "#ffffff",
      "shape": 1
    },
    {
      "id": 10,
      "type": "LF_DisplayString",
      "pos": [
        2760,
        -800
      ],
      "size": [
        845,
        1310
      ],
      "flags": {},
      "order": 10,
      "mode": 0,
      "inputs": [
        {
          "name": "string",
          "type": "STRING",
          "link": 51,
          "widget": {
            "name": "string"
          }
        }
      ],
      "outputs": [
        {
          "name": "string",
          "type": "STRING",
          "links": null
        }
      ],
      "properties": {
        "Node name for S&R": "LF_DisplayString",
        "ttNbgOverride": {
          "color": "#222",
          "bgcolor": "#000",
          "groupcolor": "#444"
        }
      },
      "widgets_values": [
        "",
        "# LF_WallOfText\n\n### Summary\nThe LF_WallOfText node generates a wall of text by concatenating input strings, optionally shuffling them, and sending the result to the PromptServer.\n\n---\n\n## 📥 Inputs\n\n| Parameter      | Type     | Default Value | Description |\n|----------------|----------|---------------|-------------|\n| separator      | STRING   | \", \"          | Character(s) separating each string apart. |\n| text_1         | STRING   | \"\"            | The first required string. |\n| text_2         | STRING   | \"\"            | The second required string. |\n| text_3-10      | STRING   | \"\"            | The third to tenth optional strings. |\n| shuffle_inputs | BOOLEAN  | False         | Toggle shuffling of input strings. |\n| seed           | INTEGER  | 42            | Seed to control the randomness of the shuffling. |\n| ui_widget     | LF_CODE  | \"\"            | Custom UI widget for node configuration. |\n| node_id       | STRING   | UNIQUE_ID     | Node ID (hidden input). |\n\n---\n\n## 📤 Outputs\n\n| Output Name    | Type     | Description |\n|----------------|----------|-------------|\n| string         | STRING   | The generated wall of text. |\n| string_list    | STRING   | The generated wall of text (always returns a single string). |\n\n---\n\n## 🔧 Execution Details\n\n- **Category**: {CATEGORY}\n- **Function Name**: `{FUNCTION}`\n- **Execution Method**: `on_exec`\n- **Unique Features**: Shuffling of input strings, customizable separator, and optional UI widget for node configuration.\n\n---\n\n### 📝 Example Output\n```json\n{\n    \"string\": \"Hello, world! Foo bar baz qux\"\n}\n```\nNote: The actual output will depend on the input values and shuffling configuration."
      ],
      "color": "#ffffff",
      "bgcolor": "#ffffff",
      "shape": 1
    },
    {
      "id": 24,
      "type": "LF_SaveMarkdown",
      "pos": [
        2355,
        -800
      ],
      "size": [
        385,
        305
      ],
      "flags": {},
      "order": 9,
      "mode": 0,
      "inputs": [
        {
          "name": "markdown_text",
          "type": "STRING",
          "link": 39,
          "widget": {
            "name": "markdown_text"
          }
        }
      ],
      "outputs": [
        {
          "name": "string",
          "type": "STRING",
          "links": [
            51
          ],
          "slot_index": 0
        }
      ],
      "properties": {
        "Node name for S&R": "LF_SaveMarkdown",
        "ttNbgOverride": {
          "color": "#222",
          "bgcolor": "#000",
          "groupcolor": "#444"
        }
      },
      "widgets_values": [
        "",
        "",
        true,
        {
          "nodes": [
            {
              "children": [
                {
                  "description": "C:\\Users\\Luca\\Documents\\GitHub\\ComfyUI\\output\\_2025-02-17_10-24-01_13.md",
                  "icon": "article",
                  "id": "C:\\Users\\Luca\\Documents\\GitHub\\ComfyUI\\output\\_2025-02-17_10-24-01_13.md",
                  "value": "C:\\Users\\Luca\\Documents\\GitHub\\ComfyUI\\output\\_2025-02-17_10-24-01_13.md"
                }
              ],
              "icon": "check",
              "id": "root",
              "value": "Markdown saved successfully!"
            }
          ]
        }
      ],
      "color": "#ffffff",
      "bgcolor": "#ffffff",
      "shape": 1
    },
    {
      "id": 5,
      "type": "LF_DisplayJSON",
      "pos": [
        1390,
        55
      ],
      "size": [
        1300,
        1075
      ],
      "flags": {},
      "order": 2,
      "mode": 0,
      "inputs": [
        {
          "name": "json_input",
          "type": "JSON",
          "link": 45
        }
      ],
      "outputs": [
        {
          "name": "json",
          "type": "JSON",
          "links": null
        }
      ],
      "properties": {
        "Node name for S&R": "LF_DisplayJSON",
        "ttNbgOverride": {
          "color": "#222",
          "bgcolor": "#000",
          "groupcolor": "#444"
        }
      },
      "widgets_values": [
        "[\n  {\n    \"file\": \"F:\\\\primitives.py\",\n    \"name\": \"LF_Boolean\",\n    \"code\": \"class LF_Boolean:\\n    @classmethod \\n    def INPUT_TYPES(self):\\n        return {\\n            \\\"required\\\": {\\n                \\\"boolean\\\": (Input.BOOLEAN, {\\n                    \\\"default\\\": False, \\n                    \\\"tooltip\\\": \\\"Boolean value.\\\"\\n                }),\\n                \\\"enable_history\\\": (Input.BOOLEAN, {\\n                    \\\"default\\\": True, \\n                    \\\"tooltip\\\": \\\"Enables history, saving the execution value and date of the widget.\\\"\\n                }),\\n                \\\"randomize\\\": (Input.BOOLEAN, {\\n                    \\\"default\\\": False, \\n                    \\\"tooltip\\\": \\\"Randomly selects a previously used value (must be present in the history list).\\\"\\n                }),\\n                \\\"seed\\\": (Input.INTEGER, {\\n                    \\\"default\\\": 42, \\n                    \\\"max\\\": INT_MAX, \\n                    \\\"tooltip\\\": \\\"Seed to control the randomness when 'randomize' is active.\\\"\\n                }),\\n            },\\n            \\\"optional\\\": {\\n                \\\"ui_widget\\\": (Input.LF_HISTORY, {\\n                    \\\"default\\\": {}\\n                }),\\n            },\\n            \\\"hidden\\\": {\\n                \\\"node_id\\\": \\\"UNIQUE_ID\\\"\\n            }\\n        }\\n\\n    CATEGORY = CATEGORY\\n    FUNCTION = FUNCTION\\n    OUTPUT_IS_LIST = (False, True)\\n    RETURN_NAMES = (\\\"boolean\\\", \\\"boolean_list\\\")\\n    RETURN_TYPES = (\\\"BOOLEAN\\\", \\\"BOOLEAN\\\")\\n\\n    def on_exec(self, **kwargs: dict):\\n        boolean: bool = normalize_list_to_value(kwargs.get(\\\"boolean\\\"))\\n        enable_history: bool = normalize_list_to_value(kwargs.get(\\\"enable_history\\\"))\\n        randomize: bool = normalize_list_to_value(kwargs.get(\\\"randomize\\\"))\\n        seed: int = normalize_list_to_value(kwargs.get(\\\"seed\\\"))\\n        ui_widget: dict = normalize_json_input(kwargs.get(\\\"ui_widget\\\", {}))\\n\\n        nodes: list[dict] = ui_widget.get(\\\"nodes\\\", [])\\n        dataset: dict = {\\n            \\\"nodes\\\": nodes\\n        }\\n\\n        if enable_history:\\n            create_history_node(str(boolean), nodes)\\n\\n        if randomize:\\n            result = randomize_from_history(nodes, seed)\\n            boolean = True if result.lower() == \\\"true\\\" else False\\n            \\n        PromptServer.instance.send_sync(f\\\"{EVENT_PREFIX}boolean\\\", {\\n            \\\"node\\\": kwargs.get(\\\"node_id\\\"),\\n            \\\"dataset\\\": dataset,\\n        })\\n\\n        return (boolean, [boolean])\",\n    \"constants\": [\n      \"INTEGER\",\n      \"EVENT_PREFIX\",\n      \"INT_MAX\",\n      \"INPUT_TYPES\",\n      \"LF_HISTORY\",\n      \"BOOLEAN\",\n      \"UNIQUE_ID\"\n    ],\n    \"helperFunctions\": [\n      \"get\",\n      \"value\",\n      \"randomize_from_history\",\n      \"normalize_json_input\",\n      \"create_history_node\",\n      \"str\",\n      \"normalize_list_to_value\",\n      \"lower\",\n      \"return\",\n      \"send_sync\"\n    ]\n  },\n  {\n    \"file\": \"F:\\\\primitives.py\",\n    \"name\": \"LF_DisplayBoolean\",\n    \"code\": \"class LF_DisplayBoolean:\\n    @classmethod \\n    def INPUT_TYPES(self):\\n        return {\\n            \\\"required\\\": {\\n                \\\"boolean\\\": (Input.BOOLEAN, {\\n                    \\\"default\\\": False, \\n                    \\\"forceInput\\\": True, \\n                    \\\"tooltip\\\": \\\"Boolean value.\\\"\\n                }),\\n            },\\n            \\\"optional\\\": {\\n                \\\"ui_widget\\\": (Input.LF_CODE, {\\n                    \\\"default\\\": \\\"\\\"\\n                }),\\n            },\\n            \\\"hidden\\\": {\\n                \\\"node_id\\\": \\\"UNIQUE_ID\\\"\\n            }\\n        }\\n\\n    CATEGORY = CATEGORY\\n    FUNCTION = FUNCTION\\n    OUTPUT_NODE = True\\n    RETURN_NAMES = (\\\"boolean\\\",)\\n    RETURN_TYPES = (\\\"BOOLEAN\\\",)\\n\\n    def on_exec(self, **kwargs: dict):\\n        display_boolean: bool = normalize_input_list(kwargs.get(\\\"boolean\\\"))\\n\\n        if isinstance(display_boolean, list):\\n            if len(display_boolean) > 1:\\n                markdown_value = \\\"\\\\n\\\\n\\\".join(f\\\"{i+1}. {item}\\\" for i, item in enumerate(display_boolean))\\n            else:\\n                markdown_value = str(display_boolean[0])\\n        else:\\n            markdown_value = \\\"\\\"\\n        \\n        PromptServer.instance.send_sync(f\\\"{EVENT_PREFIX}displayboolean\\\", {\\n            \\\"node\\\": kwargs.get(\\\"node_id\\\"),\\n            \\\"value\\\": markdown_value,\\n        })\\n\\n        return (kwargs.get(\\\"boolean\\\"),)\",\n    \"constants\": [\n      \"LF_CODE\",\n      \"EVENT_PREFIX\",\n      \"INPUT_TYPES\",\n      \"BOOLEAN\",\n      \"UNIQUE_ID\"\n    ],\n    \"helperFunctions\": [\n      \"get\",\n      \"enumerate\",\n      \"normalize_input_list\",\n      \"join\",\n      \"str\",\n      \"len\",\n      \"return\",\n      \"isinstance\",\n      \"send_sync\"\n    ]\n  },\n  {\n    \"file\": \"F:\\\\primitives.py\",\n    \"name\": \"LF_DisplayFloat\",\n    \"code\": \"class LF_DisplayFloat:\\n    @classmethod \\n    def INPUT_TYPES(self):\\n        return {\\n            \\\"required\\\": {\\n                \\\"float\\\": (Input.FLOAT, {\\n                    \\\"default\\\": 0, \\n                    \\\"forceInput\\\": True, \\n                    \\\"tooltip\\\": \\\"Float value.\\\"\\n                }),\\n            },\\n            \\\"optional\\\": {\\n                \\\"ui_widget\\\": (Input.LF_CODE, {\\n                    \\\"default\\\": \\\"\\\"\\n                }),\\n            },\\n            \\\"hidden\\\": {\\n                \\\"node_id\\\": \\\"UNIQUE_ID\\\"\\n            }\\n        }\\n\\n    CATEGORY = CATEGORY\\n    FUNCTION = FUNCTION\\n    OUTPUT_NODE = True\\n    RETURN_NAMES = (\\\"float\\\",)\\n    RETURN_TYPES = (\\\"FLOAT\\\",)\\n\\n    def on_exec(self, **kwargs: dict):\\n        display_float: float = normalize_input_list(kwargs.get(\\\"float\\\"))\\n\\n        if isinstance(display_float, list):\\n            if len(display_float) > 1:\\n                markdown_value = \\\"\\\\n\\\\n\\\".join(f\\\"{i+1}. {item}\\\" for i, item in enumerate(display_float))\\n            else:\\n                markdown_value = str(display_float[0])\\n        else:\\n            markdown_value = \\\"\\\"\\n        \\n        PromptServer.instance.send_sync(f\\\"{EVENT_PREFIX}displayfloat\\\", {\\n            \\\"node\\\": kwargs.get(\\\"node_id\\\"),\\n            \\\"value\\\": markdown_value,\\n        })\\n\\n        return (kwargs.get(\\\"float\\\"),)\",\n    \"constants\": [\n      \"LF_CODE\",\n      \"EVENT_PREFIX\",\n      \"FLOAT\",\n      \"INPUT_TYPES\",\n      \"UNIQUE_ID\"\n    ],\n    \"helperFunctions\": [\n      \"get\",\n      \"enumerate\",\n      \"normalize_input_list\",\n      \"join\",\n      \"str\",\n      \"len\",\n      \"return\",\n      \"isinstance\",\n      \"send_sync\"\n    ]\n  },\n  {\n    \"file\": \"F:\\\\primitives.py\",\n    \"name\": \"LF_DisplayInteger\",\n    \"code\": \"class LF_DisplayInteger:\\n    @classmethod \\n    def INPUT_TYPES(self):\\n        return {\\n            \\\"required\\\": {\\n                \\\"integer\\\": (Input.INTEGER, {\\n                    \\\"default\\\": 0, \\n                    \\\"forceInput\\\": True, \\n                    \\\"tooltip\\\": \\\"Integer value.\\\"\\n                }),\\n            },\\n            \\\"optional\\\": {\\n                \\\"ui_widget\\\": (Input.LF_CODE, {\\n                    \\\"default\\\": \\\"\\\"\\n                }),\\n            },\\n            \\\"hidden\\\": {\\n                \\\"node_id\\\": \\\"UNIQUE_ID\\\"\\n            }\\n        }\\n\\n    CATEGORY = CATEGORY\\n    FUNCTION = FUNCTION\\n    OUTPUT_NODE = True\\n    RETURN_NAMES = (\\\"integer\\\",)\\n    RETURN_TYPES = (\\\"INT\\\",)\\n\\n    def on_exec(self, **kwargs: dict):\\n        display_integer: int = normalize_input_list(kwargs.get(\\\"integer\\\"))\\n\\n        if isinstance(display_integer, list):\\n            if len(display_integer) > 1:\\n                markdown_value = \\\"\\\\n\\\\n\\\".join(f\\\"{i+1}. {item}\\\" for i, item in enumerate(display_integer))\\n            else:\\n                markdown_value = str(display_integer[0])\\n        else:\\n            markdown_value = \\\"\\\"\\n        \\n        PromptServer.instance.send_sync(f\\\"{EVENT_PREFIX}displayinteger\\\", {\\n            \\\"node\\\": kwargs.get(\\\"node_id\\\"),\\n            \\\"value\\\": markdown_value,\\n        })\\n\\n        return (kwargs.get(\\\"integer\\\"),)\",\n    \"constants\": [\n      \"LF_CODE\",\n      \"INTEGER\",\n      \"EVENT_PREFIX\",\n      \"INPUT_TYPES\",\n      \"UNIQUE_ID\",\n      \"INT\"\n    ],\n    \"helperFunctions\": [\n      \"get\",\n      \"enumerate\",\n      \"normalize_input_list\",\n      \"join\",\n      \"str\",\n      \"len\",\n      \"return\",\n      \"isinstance\",\n      \"send_sync\"\n    ]\n  },\n  {\n    \"file\": \"F:\\\\primitives.py\",\n    \"name\": \"LF_DisplayPrimitiveAsJSON\",\n    \"code\": \"class LF_DisplayPrimitiveAsJSON:\\n    @classmethod\\n    def INPUT_TYPES(self):\\n        return {\\n            \\\"required\\\": {},\\n            \\\"optional\\\": {\\n                \\\"integer\\\": (Input.INTEGER, {\\n                    \\\"default\\\": 0, \\n                    \\\"forceInput\\\": True, \\n                    \\\"max\\\": INT_MAX, \\n                    \\\"tooltip\\\": \\\"Integer value.\\\"\\n                }),\\n                \\\"float\\\": (Input.FLOAT, {\\n                    \\\"default\\\": 0.0, \\n                    \\\"forceInput\\\": True, \\n                    \\\"step\\\": 0.1, \\n                    \\\"tooltip\\\": \\\"Float value.\\\"\\n                }),\\n                \\\"string\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"forceInput\\\": True, \\n                    \\\"multiline\\\": True, \\n                    \\\"tooltip\\\": \\\"String value.\\\"\\n                }),\\n                \\\"boolean\\\": (Input.BOOLEAN, {\\n                    \\\"default\\\": False, \\n                    \\\"forceInput\\\": True, \\n                    \\\"tooltip\\\": \\\"Boolean value.\\\"\\n                }),\\n                \\\"ui_widget\\\": (Input.LF_CODE, {\\n                    \\\"default\\\": \\\"\\\"\\n                }),\\n            },\\n            \\\"hidden\\\": {\\n                \\\"node_id\\\": \\\"UNIQUE_ID\\\"\\n            }\\n        }\\n\\n    CATEGORY = CATEGORY\\n    FUNCTION = FUNCTION\\n    OUTPUT_NODE = True\\n    RETURN_NAMES = (\\\"json\\\",)\\n    RETURN_TYPES = (\\\"JSON\\\",)\\n\\n    def on_exec(self, **kwargs: dict):\\n        integer_list: int = normalize_input_list(kwargs.get(\\\"integer\\\"))\\n        float_list: float = normalize_input_list(kwargs.get(\\\"float\\\"))\\n        string_list: str = normalize_input_list(kwargs.get(\\\"string\\\"))\\n        boolean_list: bool = normalize_input_list(kwargs.get(\\\"boolean\\\"))\\n\\n        nodes: list[dict] = []\\n        dataset: dict = {\\\"nodes\\\": nodes}\\n\\n        if boolean_list:\\n            for idx, value in enumerate(boolean_list):\\n                nodes.append({\\n                    \\\"children\\\": [{\\\"id\\\": f\\\"boolean_{idx}\\\", \\\"value\\\": str(value)}],\\n                    \\\"description\\\": str(value), \\\"id\\\": f\\\"boolean_{idx}\\\", \\\"value\\\": \\\"boolean\\\"\\n                })\\n        \\n        if float_list:\\n            for idx, value in enumerate(float_list):\\n                nodes.append({\\n                    \\\"children\\\": [{\\\"id\\\": f\\\"float_{idx}\\\", \\\"value\\\": str(value)}],\\n                    \\\"description\\\": str(value), \\\"id\\\": f\\\"float_{idx}\\\", \\\"value\\\": \\\"float\\\"\\n                })\\n        \\n        if integer_list:\\n            for idx, value in enumerate(integer_list):\\n                nodes.append({\\n                    \\\"children\\\": [{\\\"id\\\": f\\\"integer_{idx}\\\", \\\"value\\\": str(value)}],\\n                    \\\"description\\\": str(value), \\\"id\\\": f\\\"integer_{idx}\\\", \\\"value\\\": \\\"integer\\\"\\n                })\\n        \\n        if string_list:\\n            for idx, value in enumerate(string_list):\\n                nodes.append({\\n                    \\\"children\\\": [{\\\"id\\\": f\\\"string_{idx}\\\", \\\"value\\\": value}],\\n                    \\\"description\\\": value, \\\"id\\\": f\\\"string_{idx}\\\", \\\"value\\\": \\\"string\\\"\\n                })\\n\\n        PromptServer.instance.send_sync(f\\\"{EVENT_PREFIX}displayprimitiveasjson\\\", {\\n            \\\"node\\\": kwargs.get(\\\"node_id\\\"),\\n            \\\"value\\\": dataset,\\n        })\\n\\n        return (dataset,)\",\n    \"constants\": [\n      \"LF_CODE\",\n      \"INTEGER\",\n      \"EVENT_PREFIX\",\n      \"INT_MAX\",\n      \"FLOAT\",\n      \"INPUT_TYPES\",\n      \"BOOLEAN\",\n      \"STRING\",\n      \"UNIQUE_ID\",\n      \"JSON\"\n    ],\n    \"helperFunctions\": [\n      \"get\",\n      \"enumerate\",\n      \"normalize_input_list\",\n      \"str\",\n      \"return\",\n      \"append\",\n      \"send_sync\"\n    ]\n  },\n  {\n    \"file\": \"F:\\\\primitives.py\",\n    \"name\": \"LF_DisplayString\",\n    \"code\": \"class LF_DisplayString:\\n    @classmethod \\n    def INPUT_TYPES(self):\\n        return {\\n            \\\"required\\\": {\\n                \\\"string\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"forceInput\\\": True, \\n                    \\\"tooltip\\\": \\\"String value.\\\"\\n                }),\\n            },\\n            \\\"optional\\\": {\\n                \\\"ui_widget\\\": (Input.LF_CODE, {\\n                    \\\"default\\\": \\\"\\\"\\n                }),\\n            },\\n            \\\"hidden\\\": {\\n                \\\"node_id\\\": \\\"UNIQUE_ID\\\"\\n            }\\n        }\\n\\n    CATEGORY = CATEGORY\\n    FUNCTION = FUNCTION\\n    OUTPUT_NODE = True\\n    RETURN_NAMES = (\\\"string\\\",)\\n    RETURN_TYPES = (\\\"STRING\\\",)\\n\\n    def on_exec(self, **kwargs: dict):\\n        display_string:str = normalize_input_list(kwargs.get(\\\"string\\\"))\\n\\n        if isinstance(display_string, list):\\n            if len(display_string) > 1:\\n                markdown_value = \\\"\\\\n\\\\n\\\".join(f\\\"{i+1}. {item}\\\" for i, item in enumerate(display_string))\\n            else:\\n                markdown_value = display_string[0]\\n        else:\\n            markdown_value = \\\"\\\"\\n        \\n        PromptServer.instance.send_sync(f\\\"{EVENT_PREFIX}displaystring\\\", {\\n            \\\"node\\\": kwargs.get(\\\"node_id\\\"),\\n            \\\"value\\\": markdown_value,\\n        })\\n\\n        return (kwargs.get(\\\"string\\\"),)\",\n    \"constants\": [\n      \"LF_CODE\",\n      \"EVENT_PREFIX\",\n      \"INPUT_TYPES\",\n      \"STRING\",\n      \"UNIQUE_ID\"\n    ],\n    \"helperFunctions\": [\n      \"get\",\n      \"enumerate\",\n      \"normalize_input_list\",\n      \"join\",\n      \"len\",\n      \"return\",\n      \"isinstance\",\n      \"send_sync\"\n    ]\n  },\n  {\n    \"file\": \"F:\\\\primitives.py\",\n    \"name\": \"LF_Float\",\n    \"code\": \"class LF_Float:\\n    @classmethod \\n    def INPUT_TYPES(self):\\n        return {\\n            \\\"required\\\": {\\n                \\\"float\\\": (Input.FLOAT, {\\n                    \\\"default\\\": 0, \\n                    \\\"step\\\": 0.1, \\n                    \\\"tooltip\\\": \\\"Float value.\\\"\\n                }),\\n                \\\"enable_history\\\": (Input.BOOLEAN, {\\n                    \\\"default\\\": True, \\n                    \\\"tooltip\\\": \\\"Enables history, saving the execution value and date of the widget.\\\"\\n                }),\\n                \\\"randomize\\\": (Input.BOOLEAN, {\\n                    \\\"default\\\": False, \\n                    \\\"tooltip\\\": \\\"Randomly selects a previously used value (must be present in the history list).\\\"\\n                }),\\n                \\\"seed\\\": (Input.INTEGER, {\\n                    \\\"default\\\": 42, \\n                    \\\"max\\\": INT_MAX, \\n                    \\\"tooltip\\\": \\\"Seed to control the randomness when 'randomize' is active.\\\"\\n                }),\\n            },\\n            \\\"optional\\\": {\\n                \\\"ui_widget\\\": (Input.LF_HISTORY, {\\n                    \\\"default\\\": {}\\n                }),\\n            },\\n            \\\"hidden\\\": {\\n                \\\"node_id\\\": \\\"UNIQUE_ID\\\"\\n            }\\n        }\\n\\n    CATEGORY = CATEGORY\\n    FUNCTION = FUNCTION\\n    OUTPUT_IS_LIST = (False, True)\\n    RETURN_NAMES = (\\\"float\\\", \\\"float_list\\\")\\n    RETURN_TYPES = (\\\"FLOAT\\\", \\\"FLOAT\\\")\\n\\n    def on_exec(self, **kwargs: dict):\\n        float_input: float = normalize_list_to_value(kwargs.get(\\\"float\\\"))\\n        enable_history: bool = normalize_list_to_value(kwargs.get(\\\"enable_history\\\"))\\n        randomize: bool = normalize_list_to_value(kwargs.get(\\\"randomize\\\"))\\n        seed: int = normalize_list_to_value(kwargs.get(\\\"seed\\\"))\\n        ui_widget: dict = normalize_json_input(kwargs.get(\\\"ui_widget\\\", {}))\\n\\n        nodes = ui_widget.get(\\\"nodes\\\", [])\\n        dataset = {\\n            \\\"nodes\\\": nodes\\n        }\\n\\n        if enable_history:\\n            create_history_node(str(float_input), nodes)\\n\\n        if randomize:\\n            float_input = float(randomize_from_history(nodes, seed))\\n                \\n        PromptServer.instance.send_sync(f\\\"{EVENT_PREFIX}float\\\", {\\n            \\\"node\\\": kwargs.get(\\\"node_id\\\"),\\n            \\\"dataset\\\": dataset,\\n        })\\n\\n        return (float_input, [float_input])\",\n    \"constants\": [\n      \"INTEGER\",\n      \"EVENT_PREFIX\",\n      \"INT_MAX\",\n      \"FLOAT\",\n      \"INPUT_TYPES\",\n      \"BOOLEAN\",\n      \"LF_HISTORY\",\n      \"UNIQUE_ID\"\n    ],\n    \"helperFunctions\": [\n      \"get\",\n      \"value\",\n      \"randomize_from_history\",\n      \"normalize_json_input\",\n      \"create_history_node\",\n      \"str\",\n      \"normalize_list_to_value\",\n      \"return\",\n      \"float\",\n      \"send_sync\"\n    ]\n  },\n  {\n    \"file\": \"F:\\\\primitives.py\",\n    \"name\": \"LF_Integer\",\n    \"code\": \"class LF_Integer:\\n    @classmethod \\n    def INPUT_TYPES(self):\\n        return {\\n            \\\"required\\\": {\\n                \\\"integer\\\": (Input.INTEGER, {\\n                    \\\"default\\\": 0, \\n                    \\\"max\\\": INT_MAX, \\n                    \\\"tooltip\\\": \\\"Integer value.\\\"\\n                }),\\n                \\\"enable_history\\\": (Input.BOOLEAN, {\\n                    \\\"default\\\": True, \\n                    \\\"tooltip\\\": \\\"Enables history, saving the execution value and date of the widget.\\\"\\n                }),\\n                \\\"randomize\\\": (Input.BOOLEAN, {\\n                    \\\"default\\\": False, \\n                    \\\"tooltip\\\": \\\"Randomly selects a previously used value (must be present in the history list).\\\"\\n                }),\\n                \\\"seed\\\": (Input.INTEGER, {\\n                    \\\"default\\\": 42, \\n                    \\\"max\\\": INT_MAX, \\n                    \\\"tooltip\\\": \\\"Seed to control the randomness when 'randomize' is active.\\\"\\n                }),\\n            },\\n            \\\"optional\\\": {\\n                \\\"ui_widget\\\": (Input.LF_HISTORY, {\\n                    \\\"default\\\": {}\\n                }),\\n            },\\n            \\\"hidden\\\": {\\n                \\\"node_id\\\": \\\"UNIQUE_ID\\\"\\n            }\\n        }\\n\\n    CATEGORY = CATEGORY\\n    FUNCTION = FUNCTION\\n    OUTPUT_IS_LIST = (False, True)\\n    RETURN_NAMES = (\\\"int\\\", \\\"int_list\\\")\\n    RETURN_TYPES = (\\\"INT\\\", \\\"INT\\\")\\n\\n    def on_exec(self, **kwargs: dict):\\n        integer_input: int = normalize_list_to_value(kwargs.get(\\\"integer\\\"))\\n        enable_history: bool = normalize_list_to_value(kwargs.get(\\\"enable_history\\\"))\\n        randomize: bool = normalize_list_to_value(kwargs.get(\\\"randomize\\\"))\\n        seed: int = normalize_list_to_value(kwargs.get(\\\"seed\\\"))\\n        ui_widget: dict = normalize_json_input(kwargs.get(\\\"ui_widget\\\", {}))\\n\\n        nodes = ui_widget.get(\\\"nodes\\\", [])\\n        dataset = {\\n            \\\"nodes\\\": nodes\\n        }\\n\\n        if enable_history:\\n            create_history_node(str(integer_input), nodes)\\n\\n        if randomize:\\n            integer_input = int(randomize_from_history(nodes, seed))\\n\\n        PromptServer.instance.send_sync(f\\\"{EVENT_PREFIX}integer\\\", {\\n            \\\"node\\\": kwargs.get(\\\"node_id\\\"),\\n            \\\"dataset\\\": dataset\\n        })\\n\\n        return (integer_input, [integer_input])\",\n    \"constants\": [\n      \"INTEGER\",\n      \"EVENT_PREFIX\",\n      \"INT_MAX\",\n      \"INPUT_TYPES\",\n      \"LF_HISTORY\",\n      \"BOOLEAN\",\n      \"UNIQUE_ID\",\n      \"INT\"\n    ],\n    \"helperFunctions\": [\n      \"get\",\n      \"value\",\n      \"int\",\n      \"randomize_from_history\",\n      \"normalize_json_input\",\n      \"create_history_node\",\n      \"str\",\n      \"normalize_list_to_value\",\n      \"return\",\n      \"send_sync\"\n    ]\n  },\n  {\n    \"file\": \"F:\\\\primitives.py\",\n    \"name\": \"LF_RandomBoolean\",\n    \"code\": \"class LF_RandomBoolean:\\n    @classmethod\\n    def INPUT_TYPES(self):\\n        return {\\n            \\\"required\\\": {\\n                \\\"chance_true\\\": (Input.FLOAT, {\\n                    \\\"default\\\": 50.0, \\n                    \\\"step\\\": 1, \\n                    \\\"min\\\": 0, \\n                    \\\"max\\\": 100, \\n                    \\\"tooltip\\\": \\\"Percentage chance for True output, 0-100.\\\"\\n                }),\\n            },\\n            \\\"optional\\\": {\\n                \\\"ui_widget\\\": (Input.LF_PROGRESSBAR, {\\n                    \\\"default\\\": {}\\n                }),\\n            },\\n            \\\"hidden\\\": {\\n                \\\"node_id\\\": \\\"UNIQUE_ID\\\"\\n            }\\n        }\\n\\n    CATEGORY = CATEGORY\\n    FUNCTION = FUNCTION\\n    OUTPUT_IS_LIST = (False, True)\\n    RETURN_NAMES = (\\\"boolean\\\", \\\"boolean_list\\\")\\n    RETURN_TYPES = (\\\"BOOLEAN\\\", \\\"BOOLEAN\\\")\\n\\n    def on_exec(self, **kwargs: dict):\\n        chance_true: str = normalize_list_to_value(kwargs.get(\\\"chance_true\\\"))\\n        \\n        percentage = max(0, min(100, chance_true))\\n        random_value = random.uniform(0, 100)\\n\\n        result = random_value <= percentage\\n\\n        PromptServer.instance.send_sync(f\\\"{EVENT_PREFIX}randomboolean\\\", {\\n            \\\"node\\\": kwargs.get(\\\"node_id\\\"),\\n            \\\"bool\\\": result,\\n            \\\"roll\\\": random_value,\\n        })\\n\\n        return (result, [result])\\n\\n    @classmethod\\n    def IS_CHANGED(cls, **kwargs):\\n        return float(\\\"NaN\\\")\",\n    \"constants\": [\n      \"IS_CHANGED\",\n      \"EVENT_PREFIX\",\n      \"LF_PROGRESSBAR\",\n      \"FLOAT\",\n      \"INPUT_TYPES\",\n      \"BOOLEAN\",\n      \"UNIQUE_ID\"\n    ],\n    \"helperFunctions\": [\n      \"get\",\n      \"min\",\n      \"normalize_list_to_value\",\n      \"uniform\",\n      \"return\",\n      \"float\",\n      \"max\",\n      \"send_sync\"\n    ]\n  },\n  {\n    \"file\": \"F:\\\\primitives.py\",\n    \"name\": \"LF_Something2Number\",\n    \"code\": \"class LF_Something2Number:\\n    @classmethod\\n    def INPUT_TYPES(self):\\n        return {\\n            \\\"required\\\": {},\\n            \\\"optional\\\": {\\n                \\\"JSON\\\": (Input.JSON, {\\n                    \\\"tooltip\\\": \\\"JSON value to convert to numbers.\\\"\\n                }),\\n                \\\"boolean\\\": (Input.BOOLEAN, {\\n                    \\\"tooltip\\\": \\\"Boolean value to convert to numbers.\\\"\\n                }),\\n                \\\"string\\\": (Input.STRING, {\\n                    \\\"tooltip\\\": \\\"String value to convert to numbers.\\\"\\n                }),\\n                \\\"integer\\\": (Input.INTEGER, {\\n                    \\\"tooltip\\\": \\\"Integer value to convert to numbers.\\\"\\n                }),\\n                \\\"float\\\": (Input.FLOAT, {\\n                    \\\"tooltip\\\": \\\"Float value to convert to numbers.\\\"\\n                }),\\n                \\\"ui_widget\\\": (Input.LF_CODE, {\\n                    \\\"default\\\": \\\"\\\"\\n                }),\\n            },\\n            \\\"hidden\\\": {\\n                \\\"node_id\\\": \\\"UNIQUE_ID\\\"\\n            }\\n        }\\n\\n    CATEGORY = CATEGORY\\n    FUNCTION = FUNCTION\\n    OUTPUT_IS_LIST = (False, False, False, False, True, True)\\n    RETURN_NAMES = (\\\"float_sum\\\", \\\"int_sum\\\", \\\"float_list\\\", \\\"int_list\\\")\\n    RETURN_TYPES = (\\\"FLOAT\\\", \\\"INT\\\", \\\"FLOAT\\\", \\\"INT\\\")\\n\\n    def on_exec(self, **kwargs: dict):\\n        def extract_numbers(data):\\n            if isinstance(data, bool):\\n                i_val = 1 if data else 0\\n                f_val = 1.0 if data else 0.0\\n                float_values.append(f_val)\\n                integer_values.append(i_val)\\n                breakdown.append(f\\\"**boolean** detected => {f_val} (float) {i_val} (int)\\\")\\n            elif isinstance(data, (int, float)):\\n                i_val = int(data)\\n                f_val = float(data)\\n                float_values.append(f_val)\\n                integer_values.append(i_val)\\n                breakdown.append(f\\\"**number** detected => {f_val} (float) {i_val} (int)\\\")\\n            elif isinstance(data, str):\\n                try:\\n                    f_val = float(data.strip())\\n                    i_val = int(f_val)\\n                    float_values.append(f_val)\\n                    integer_values.append(i_val)\\n                    breakdown.append(f\\\"**string** detected => {f_val} (float) {i_val} (int)\\\")\\n                except ValueError:\\n                    try:\\n                        parsed_json = json.loads(data)\\n                        extract_numbers(parsed_json)\\n                    except json.JSONDecodeError:\\n                        pass\\n            elif isinstance(data, dict):\\n                for value in data.values():\\n                    extract_numbers(value)\\n            elif isinstance(data, (list, tuple, set)):\\n                for item in data:\\n                    extract_numbers(item)\\n\\n        empty = \\\"*Empty*\\\"\\n        float_values = []\\n        integer_values = []\\n        breakdown = []\\n\\n        for value in kwargs.values():\\n            extract_numbers(value)\\n\\n        float_sum = sum(float_values)\\n        integer_sum = sum(integer_values)\\n        \\n        float_log = \\\"\\\\n\\\".join([str(val) for val in float_values]) if float_values else empty\\n        int_log = \\\"\\\\n\\\".join([str(val) for val in integer_values]) if integer_values else empty\\n        breakdown_log = \\\"\\\\n\\\".join([f\\\"{i+1}. {val}\\\" for i, val in enumerate(breakdown)]) if breakdown else empty\\n\\n        log = f\\\"\\\"\\\"## Result:\\n  **Float sum: {str(float_sum)}**\\n  **Integer sum: {str(integer_sum)}**\\n\\n## List of floats:\\n  {float_log}\\n\\n## List of integers:\\n  {int_log}\\n\\n## Breakdown:\\n\\n  {breakdown_log}\\n    \\\"\\\"\\\"\\n        PromptServer.instance.send_sync(f\\\"{EVENT_PREFIX}something2number\\\", {\\n            \\\"node\\\": kwargs.get(\\\"node_id\\\"), \\n            \\\"value\\\": log,\\n        })\\n\\n        return (float_sum, integer_sum, float_values, integer_values)\",\n    \"constants\": [\n      \"LF_CODE\",\n      \"INTEGER\",\n      \"EVENT_PREFIX\",\n      \"FLOAT\",\n      \"INPUT_TYPES\",\n      \"JSON\",\n      \"STRING\",\n      \"BOOLEAN\",\n      \"INT\",\n      \"UNIQUE_ID\"\n    ],\n    \"helperFunctions\": [\n      \"enumerate\",\n      \"int\",\n      \"strip\",\n      \"return\",\n      \"float\",\n      \"loads\",\n      \"isinstance\",\n      \"append\",\n      \"get\",\n      \"join\",\n      \"str\",\n      \"sum\",\n      \"values\",\n      \"send_sync\"\n    ]\n  },\n  {\n    \"file\": \"F:\\\\primitives.py\",\n    \"name\": \"LF_Something2String\",\n    \"code\": \"class LF_Something2String:\\n    @classmethod\\n    def INPUT_TYPES(self):\\n        return {\\n            \\\"required\\\": {\\n                \\\"separator\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\", \\\", \\n                    \\\"tooltip\\\": \\\"Character(s) separating each string apart.\\\"\\n                }),\\n            },\\n            \\\"optional\\\": {\\n                \\\"json\\\": (Input.JSON, {\\n                    \\\"tooltip\\\": \\\"JSON value to convert to string.\\\"\\n                }),\\n                \\\"boolean\\\": (Input.BOOLEAN, {\\n                    \\\"tooltip\\\": \\\"Boolean value to convert to string.\\\"\\n                }),\\n                \\\"float\\\": (Input.FLOAT, {\\n                    \\\"tooltip\\\": \\\"Float value to convert to string.\\\"\\n                }),\\n                \\\"integer\\\": (Input.INTEGER, {\\n                    \\\"tooltip\\\": \\\"Integer value to convert to string.\\\"\\n                }),\\n                \\\"ui_widget\\\": (Input.LF_CODE, {\\n                    \\\"default\\\": \\\"\\\"\\n                }),\\n            },\\n            \\\"hidden\\\": {\\n                \\\"node_id\\\": \\\"UNIQUE_ID\\\"\\n            }\\n        }\\n\\n    CATEGORY = CATEGORY\\n    FUNCTION = FUNCTION\\n\\n    input_keys = [\\\"json\\\", \\\"boolean\\\", \\\"float\\\", \\\"integer\\\"]\\n    combinations_list = []\\n\\n    for r in range(1, len(input_keys) + 1):\\n        for combo in combinations(input_keys, r):\\n            combo_name = \\\"_\\\".join(combo)\\n            combinations_list.append(combo_name)\\n\\n    OUTPUT_IS_LIST = tuple([False] * len(combinations_list))\\n    RETURN_TYPES = tuple([\\\"STRING\\\"] * len(combinations_list))\\n    RETURN_NAMES = tuple(combinations_list)\\n\\n    def on_exec(self, **kwargs: dict):\\n        def flatten_input(input_item):\\n            if isinstance(input_item, list):\\n                return [str(sub_item) for item in input_item for sub_item in flatten_input(item)]\\n            elif isinstance(input_item, (dict, bool, float, int)):\\n                flattened_value = str(input_item)\\n                breakdown.append(f\\\"**{type(input_item).__name__}** detected => {flattened_value}\\\")\\n                return [flattened_value]\\n            elif input_item is not None:\\n                flattened_value = str(input_item)\\n                breakdown.append(f\\\"**string** detected => {flattened_value}\\\")\\n                return [flattened_value]\\n            return []\\n\\n        separator = kwargs.get(\\\"separator\\\", \\\", \\\")\\n        breakdown = []\\n\\n        results = []\\n        combination_logs = []\\n\\n        for combo_name in self.RETURN_NAMES:\\n            items = combo_name.split(\\\"_\\\")\\n            flattened_combo = []\\n\\n            for item in items:\\n                if item in kwargs:\\n                    flattened_combo.extend(flatten_input(kwargs[item]))\\n\\n            combined_string = separator.join(flattened_combo)\\n            results.append(combined_string)\\n            combination_logs.append(f\\\"**{combo_name}** => {combined_string}\\\")\\n\\n        flattened_log = \\\"\\\\n\\\".join([f\\\"{i+1}. {val}\\\" for i, val in enumerate(breakdown)]) if breakdown else \\\"*Empty*\\\"\\n        combinations_log = \\\"\\\\n\\\".join([f\\\"{i+1}. {val}\\\" for i, val in enumerate(combination_logs)]) if combination_logs else \\\"*Empty*\\\"\\n\\n        log = f\\\"\\\"\\\"## Breakdown\\n\\n{flattened_log}\\n\\n## Combination Results:\\n{combinations_log}\\n        \\\"\\\"\\\"\\n        \\n        PromptServer.instance.send_sync(f\\\"{EVENT_PREFIX}something2string\\\", {\\n            \\\"node\\\": kwargs.get(\\\"node_id\\\"), \\n            \\\"value\\\": log,\\n        })\\n\\n        return tuple(results)\",\n    \"constants\": [\n      \"LF_CODE\",\n      \"INTEGER\",\n      \"_\",\n      \"EVENT_PREFIX\",\n      \"FLOAT\",\n      \"INPUT_TYPES\",\n      \"JSON\",\n      \"STRING\",\n      \"BOOLEAN\",\n      \"UNIQUE_ID\"\n    ],\n    \"helperFunctions\": [\n      \"enumerate\",\n      \"split\",\n      \"range\",\n      \"extend\",\n      \"isinstance\",\n      \"append\",\n      \"get\",\n      \"Character\",\n      \"join\",\n      \"str\",\n      \"combinations\",\n      \"len\",\n      \"tuple\",\n      \"type\",\n      \"send_sync\"\n    ]\n  },\n  {\n    \"file\": \"F:\\\\primitives.py\",\n    \"name\": \"LF_String\",\n    \"code\": \"class LF_String:\\n    @classmethod \\n    def INPUT_TYPES(self):\\n        return {\\n            \\\"required\\\": {\\n                \\\"string\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"multiline\\\": True, \\n                    \\\"tooltip\\\": \\\"String value.\\\"\\n                }),\\n                \\\"enable_history\\\": (Input.BOOLEAN, {\\n                    \\\"default\\\": True, \\n                    \\\"tooltip\\\": \\\"Enables history, saving the execution value and date of the widget.\\\"\\n                }),\\n                \\\"randomize\\\": (Input.BOOLEAN, {\\n                    \\\"default\\\": False, \\n                    \\\"tooltip\\\": \\\"Randomly selects a previously used value (must be present in the history list).\\\"\\n                }),\\n                \\\"seed\\\": (Input.INTEGER, {\\n                    \\\"default\\\": 42, \\n                    \\\"max\\\": INT_MAX, \\n                    \\\"tooltip\\\": \\\"Seed to control the randomness when 'randomize' is active.\\\"\\n                }),\\n            },\\n            \\\"optional\\\": {\\n                \\\"ui_widget\\\": (Input.LF_HISTORY, {\\n                    \\\"default\\\": {}\\n                }),\\n            },\\n            \\\"hidden\\\": {\\n                \\\"node_id\\\": \\\"UNIQUE_ID\\\"\\n            }\\n        }\\n\\n    CATEGORY = CATEGORY\\n    FUNCTION = FUNCTION\\n    OUTPUT_IS_LIST = (False, True)\\n    RETURN_NAMES = (\\\"string\\\", \\\"string_list\\\")\\n    RETURN_TYPES = (\\\"STRING\\\", \\\"STRING\\\")\\n\\n    def on_exec(self, **kwargs: dict):\\n        string_input: str = normalize_list_to_value(kwargs.get(\\\"string\\\"))\\n        enable_history: bool = normalize_list_to_value(kwargs.get(\\\"enable_history\\\"))\\n        randomize: bool = normalize_list_to_value(kwargs.get(\\\"randomize\\\"))\\n        seed: int = normalize_list_to_value(kwargs.get(\\\"seed\\\"))\\n        ui_widget: dict = normalize_json_input(kwargs.get(\\\"ui_widget\\\", {}))\\n\\n        nodes = ui_widget.get(\\\"nodes\\\", [])\\n        dataset = {\\n            \\\"nodes\\\": nodes\\n        }\\n\\n        if enable_history:\\n            create_history_node(string_input, nodes)\\n\\n        if randomize:\\n            string_input = randomize_from_history(nodes, seed)        \\n\\n        PromptServer.instance.send_sync(f\\\"{EVENT_PREFIX}string\\\", {\\n            \\\"node\\\": kwargs.get(\\\"node_id\\\"), \\n            \\\"dataset\\\": dataset,\\n        })\\n\\n        return (string_input, [string_input])\",\n    \"constants\": [\n      \"INTEGER\",\n      \"EVENT_PREFIX\",\n      \"INT_MAX\",\n      \"INPUT_TYPES\",\n      \"BOOLEAN\",\n      \"STRING\",\n      \"LF_HISTORY\",\n      \"UNIQUE_ID\"\n    ],\n    \"helperFunctions\": [\n      \"get\",\n      \"value\",\n      \"randomize_from_history\",\n      \"normalize_json_input\",\n      \"create_history_node\",\n      \"normalize_list_to_value\",\n      \"return\",\n      \"send_sync\"\n    ]\n  },\n  {\n    \"file\": \"F:\\\\primitives.py\",\n    \"name\": \"LF_WallOfText\",\n    \"code\": \"class LF_WallOfText:\\n    @classmethod \\n    def INPUT_TYPES(self):\\n        return {\\n            \\\"required\\\": {\\n                \\\"separator\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\", \\\", \\n                    \\\"tooltip\\\": \\\"Character(s) separating each string apart.\\\"}),\\n                \\\"text_1\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"multiline\\\": True, \\n                    \\\"tooltip\\\": \\\"The first required string.\\\"}),\\n                \\\"text_2\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"multiline\\\": True, \\n                    \\\"tooltip\\\": \\\"The second required string.\\\"}),\\n            },\\n            \\\"optional\\\": {\\n                \\\"text_3\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"defaultInput\\\": True, \\n                    \\\"tooltip\\\": \\\"The third optional string.\\\"\\n                }),\\n                \\\"text_4\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"defaultInput\\\": True, \\n                    \\\"tooltip\\\": \\\"The fourth optional string.\\\"\\n                }),\\n                \\\"text_5\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"defaultInput\\\": True, \\n                    \\\"tooltip\\\": \\\"The fifth optional string.\\\"\\n                }),\\n                \\\"text_6\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"defaultInput\\\": True, \\n                    \\\"tooltip\\\": \\\"The sixth optional string.\\\"\\n                }),\\n                \\\"text_7\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"defaultInput\\\": True, \\n                    \\\"tooltip\\\": \\\"The seventh optional string.\\\"\\n                }),\\n                \\\"text_8\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"defaultInput\\\": True, \\n                    \\\"tooltip\\\": \\\"The eighth optional string.\\\"\\n                }),\\n                \\\"text_9\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"defaultInput\\\": True, \\n                    \\\"tooltip\\\": \\\"The ninth optional string.\\\"\\n                }),\\n                \\\"text_10\\\": (Input.STRING, {\\n                    \\\"default\\\": \\\"\\\", \\n                    \\\"defaultInput\\\": True, \\n                    \\\"tooltip\\\": \\\"The tenth optional string.\\\"\\n                }),\\n                \\\"shuffle_inputs\\\": (Input.BOOLEAN, {\\n                    \\\"default\\\": False, \\n                    \\\"tooltip\\\": \\\"Toggle shuffling of input strings.\\\"\\n                }),\\n                \\\"seed\\\": (Input.INTEGER, {\\n                    \\\"default\\\": 42, \\n                    \\\"max\\\": INT_MAX, \\n                    \\\"tooltip\\\": \\\"Seed to control the randomness of the shuffling.\\\"\\n                }),\\n                \\\"ui_widget\\\": (Input.LF_CODE, {\\n                    \\\"default\\\": \\\"\\\"\\n                }),\\n            },\\n            \\\"hidden\\\": {\\n                \\\"node_id\\\": \\\"UNIQUE_ID\\\"\\n            }\\n        }\\n\\n    CATEGORY = CATEGORY\\n    FUNCTION = FUNCTION\\n    OUTPUT_IS_LIST = (False, True)\\n    RETURN_NAMES = (\\\"string\\\", \\\"string_list\\\")\\n    RETURN_TYPES = (\\\"STRING\\\", \\\"STRING\\\")\\n\\n    def on_exec(self, **kwargs: dict):\\n        texts: list[str] = [normalize_list_to_value(kwargs.get(f\\\"text_{i}\\\", \\\"\\\")) for i in range(1, 11)]\\n\\n        if len(texts) > 1:\\n            separator = kwargs.get(\\\"separator\\\", \\\"\\\")\\n            shuffle_inputs = kwargs.get(\\\"shuffle_inputs\\\", False)\\n            if shuffle_inputs:\\n                seed = kwargs.get(\\\"seed\\\", 42)\\n                random.seed(seed)\\n                random.shuffle(texts)\\n            wall_of_text = separator.join([text for text in texts if text])\\n        else:\\n            wall_of_text = texts[0]\\n\\n        PromptServer.instance.send_sync(f\\\"{EVENT_PREFIX}walloftext\\\", {\\n            \\\"node\\\": kwargs.get(\\\"node_id\\\"), \\n            \\\"value\\\": wall_of_text,\\n        })\\n\\n        return (wall_of_text, wall_of_text)\",\n    \"constants\": [\n      \"LF_CODE\",\n      \"INTEGER\",\n      \"EVENT_PREFIX\",\n      \"INT_MAX\",\n      \"INPUT_TYPES\",\n      \"BOOLEAN\",\n      \"STRING\",\n      \"UNIQUE_ID\"\n    ],\n    \"helperFunctions\": [\n      \"get\",\n      \"shuffle\",\n      \"join\",\n      \"send_sync\",\n      \"len\",\n      \"normalize_list_to_value\",\n      \"range\",\n      \"return\",\n      \"seed\",\n      \"Character\"\n    ]\n  }\n]"
      ],
      "color": "#ffffff",
      "bgcolor": "#ffffff",
      "shape": 1
    },
    {
      "id": 30,
      "type": "LF_ControlPanel",
      "pos": [
        -415,
        -1970
      ],
      "size": [
        1125,
        1955
      ],
      "flags": {},
      "order": 0,
      "mode": 0,
      "inputs": [],
      "outputs": [],
      "properties": {
        "Node name for S&R": "LF_ControlPanel"
      },
      "widgets_values": [
        {
          "backup": true,
          "debug": true,
          "themes": "light"
        }
      ],
      "color": "#ffffff",
      "bgcolor": "#ffffff",
      "shape": 1
    },
    {
      "id": 27,
      "type": "LF_RegionExtractor",
      "pos": [
        240,
        55
      ],
      "size": [
        470,
        1075
      ],
      "flags": {},
      "order": 1,
      "mode": 0,
      "inputs": [],
      "outputs": [
        {
          "name": "regions",
          "type": "JSON",
          "links": [
            45
          ]
        },
        {
          "name": "regions_list",
          "type": "JSON",
          "links": [
            46,
            47,
            49
          ],
          "slot_index": 1,
          "shape": 6
        }
      ],
      "properties": {
        "Node name for S&R": "LF_RegionExtractor",
        "ttNbgOverride": {
          "color": "#222",
          "bgcolor": "#000",
          "groupcolor": "#444"
        }
      },
      "widgets_values": [
        "F:\\",
        false,
        false,
        "py",
        {
          "nodes": [
            {
              "icon": "history",
              "id": "LF_DisplayBoolean",
              "description": "Execution date: 31/10/2024, 05:41:37.",
              "value": "LF_DisplayBoolean"
            }
          ]
        }
      ],
      "color": "#ffffff",
      "bgcolor": "#ffffff",
      "shape": 1
    }
  ],
  "links": [
    [
      37,
      8,
      1,
      25,
      0,
      "STRING"
    ],
    [
      38,
      25,
      1,
      21,
      0,
      "STRING"
    ],
    [
      39,
      21,
      3,
      24,
      0,
      "STRING"
    ],
    [
      45,
      27,
      0,
      5,
      0,
      "JSON"
    ],
    [
      46,
      27,
      1,
      6,
      0,
      "JSON"
    ],
    [
      47,
      27,
      1,
      8,
      0,
      "JSON"
    ],
    [
      49,
      27,
      1,
      29,
      0,
      "JSON"
    ],
    [
      50,
      29,
      1,
      28,
      0,
      "STRING"
    ],
    [
      51,
      24,
      0,
      10,
      0,
      "STRING"
    ]
  ],
  "groups": [],
  "config": {},
  "extra": {
    "ds": {
      "scale": 0.379749833583264,
      "offset": [
        1224.2517489340376,
        2066.923418465146
      ]
    },
    "node_versions": {
      "lf-nodes": "efccb1d68317c58ee78cc65ff54c56bea3dc27d5"
    },
    "ue_links": []
  },
  "version": 0.4
}